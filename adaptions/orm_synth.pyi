from typing import List, Union, Sequence, Annotated


class MidiMessage:

    def __init__(self, data: List[int]): ...

    def __len__(self) -> int: ...

    def __getitem__(self, item) -> Union[int, List[int]]: ...

    def is_sysex(self) -> bool: ...


class Bank:

    def __init__(self, number: int, size: int): ...

    @staticmethod
    def from_zero_base(number: int, size: int) -> Bank: ...

    @staticmethod
    def from_one_base(number: int, size: int) -> Bank: ...

    @staticmethod
    def invalid() -> Bank: ...

    def is_valid(self) -> bool: ...

    def to_zero_base(self) -> int: ...

    def to_one_base(self) -> int: ...

    def size(self) -> int: ...


class Program:

    def __init__(self, bank: Bank, program: int): ...

    @staticmethod
    def from_zero_base(program: int) -> Program: ...

    @staticmethod
    def from_one_base(program: int) -> Program: ...

    def value(self) -> int: ...


class BankDescriptor:
    bank: Annotated[Bank, "The number of the bank, each number can only be used once per synth even if bank has a different type"]
    name: Annotated[str, "User friendly naem for this bank"]
    size: Annotated[int, "The number of elements in this bank"]
    type: Annotated[str, "A user visible name for the type of elements in the bank, e.g. Patch or Tone"]
    is_rom: [bool, "Mark this True if the bank can not be written to but is in read only memory"]

    def __init__(self, bank: Bank, name: str, size: int, is_rom: bool, type: str) -> None: ...


class Patch:

    def __init__(self): ...

    def __len__(self): ...

    def __getitem__(self, item): ...


class Synth:

    def __init__(self): ...

    def get_name(self) -> str: ...

    def friendly_program_name(self, bank: Bank, program: Program) -> str: ...

    def calculate_fingerprint(self, patch: Patch): ...

    def setup_help_text(self) -> str: ...


class DiscoverableDevice:

    def __init__(self): ...

    def create_device_detect_message(self, channel: int) -> List[MidiMessage]: ...

    def device_detect_sleep_ms(self) -> int: ...

    def channel_if_valid_device_detect_response(self, message: MidiMessage) -> int: ...

    def needs_channel_specific_detection(self) -> bool: ...


class EditBufferCapability:

    def __init__(self): ...

    def request_edit_buffer(self) -> List[MidiMessage]: ...

    def is_edit_buffer(self, messages: List[MidiMessage]) -> bool: ...

    def is_part_of_edit_buffer(self, message: MidiMessage): ...

    def convert_to_edit_buffer(self, patch: Patch) -> Sequence[MidiMessage]: ...

    def save_edit_buffer(self, program: int) -> MidiMessage: ...


class BankDescriptorsCapability:

    def __init__(self): ...

    def bank_descriptors(self) -> List[BankDescriptor]: ...

    def bank_select(self, bank: Bank) -> List[MidiMessage]: ...
